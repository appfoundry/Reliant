{"name":"Reliant","body":"Reliant\r\n=======\r\n\r\nReliant is a Dependency Injection ([DI](http://martinfowler.com/articles/injection.html \"Martin Fowler never lies\")) \r\nframework for Objective-C, both for OS X and iOS. Its goal is to make it's use as simple\r\nas possible, while not limiting it's possibilities. It aims to have as little impact as\r\npossible on your project code. It also aims to be loyal to Objective-C's [dynamic](http://stackoverflow.com/questions/125367/dynamic-type-languages-versus-static-type-languages) \r\nnature.\r\n\r\nThe motivation for this library came from being used to a highly testable infrastructure\r\nin other languages thanks to DI. Looking at the typical design pattern to solve the loose\r\ncoupling problem, the [Abstract Factory pattern](http://en.wikipedia.org/wiki/Abstract_factory_pattern)\r\nis the natural solution. Although factories, in conjunction with mock libraries provide a\r\nfairly nice and testable solution, the pure loose coupling is never reached, since you\r\nstill have a dependency to a factory in almost all classes in your project, which is a\r\nrather large footprint. Before starting this library, I looked for opinions about DI in\r\ndynamic languages at the one hand, and in frontend driven solutions at the other hand.\r\nReliant is an answer to these questions.\r\n\r\n**Remark:** at the moment, Reliant is still under development, and put here for review by the\r\ncommunity. Although we consider the latest version to be pretty complete, there is still\r\nroom for improvement. Obviously, since this is open source, do feel free to add your own\r\ninsights/ideas/remarks/opinions.\r\n\r\nOverall architecture\r\n--------------------\r\n\r\nThe framework is set up to be lightweight, you basically need an OCSApplicationContext\r\nwhich serves as the container of the managed objects. To register managed objects in this\r\ncontainer, the application context uses an OCSConfigurator instance. The OCSConfigurator\r\nis responsible for creating OCSDefinitions, which describe the objects you want to put\r\nunder the application context's control.\r\n\r\nAt the moment, Reliant identifies two types of objects: singletons and prototypes. (*These\r\nnames are taken from the well know [design patterns](http://en.wikipedia.org/wiki/Software_design_pattern#Classification_and_list)*)\r\n\r\n- A singleton is a stateless shared object, which is created only once. Objects created as\r\nsingleton should be thread safe! Reliant further identifies eager and lazy singletons.\r\nEager means that they will be instantiated when the application context boots up, lazy\r\nmeans they will be instantiated *Just-in-Time*, when they are requested.\r\n\r\n**Remark:** For iOS, Reliant also reacts to memory warnings, by clearing it's singleton\r\nscope. In this case, all singletons become lazy singletons and will be initialized again\r\nwhen requested.\r\n\r\n- A prototype will be created each time it is requested from the application context. Be\r\ncarefull though! If you inject a prototype into a singleton, the prototype's livecycle is\r\nbound to the singleton!\r\n\r\nObjects are identified by a key and can have aliases, both strings. The framework makes\r\nsure these are unique. Exceptions will be thrown if an attempt is made to add an object\r\nwith a non-unique key or alias.\r\n\r\nNow let's look at a Quick start example.\r\n\r\nQuick start\r\n-----------\r\n\r\n### Including Reliant in your project\r\n\r\nTODO\r\n\r\n### Bootstrapping Reliant\r\n\r\nTo get started with Reliant, you need to tell the *OCSApplicationContext* to start up. You\r\nwill need to provide a configurator instance to the application context. More on\r\nconfigurators later, bare with us for now.\r\n\r\n```objective-c\r\n//Initialize a configurator\r\nid<OCSConfigurator> configurator = [[OCSConfiguratorFromClass alloc] \r\n\tinitWithClass:[YourObjectFactory class]];\r\n\r\n//Initialize the application context with the configurator\r\nOCSApplicationContext *context = [[OCSApplicationContext alloc] \r\n\tinitWithConfigurator:configurator];\r\n\r\n//Start the context\r\n[context start];\r\n\r\n//Done! Well...\r\n```\r\n\r\nThis will bootstrap the entire application context. At the time the start method finishes\r\nit's job, it will have loaded your defintions and it will have instantiated and injected\r\nyour eager singletons.\r\n\r\nNow where should you put this peace of code? As close as possible to where the application\r\nstartup. For iOS this means in the [application:didFinishLaunchingWithOptions:](http://developer.apple.com/library/ios/documentation/uikit/reference/UIApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UIApplicationDelegate/application:didFinishLaunchingWithOptions:) \r\nmethod in your UIApplicationDelegate. For OS X this is almost the same:\r\n[applicationDidFinishLaunching:](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSApplicationDelegate/applicationDidFinishLaunching:)\r\n in your NSApplicationDelegate.\r\n \r\n### Using the *OCSConfiguratorFromClass*\r\n\r\nThis is a ready-made configurator implementation. It uses the information found in a class\r\nprovided by you through introspection. The provided class will also serve as the creator\r\nof your objects, hence we will call it a factory class. The idea behind this is to give\r\nyou a programatic way to define objects, and make the configuration itself subject to\r\ntesting. This makes the use of external configuration files and/or macros obsolete, which\r\nyields more robust code.\r\n\r\nSo what you need to use this configurator is a factory class. The methods in this class\r\nwill be responsible for creating your objects. In order for the framework to detect these\r\nmethods, you will need to follow some naming conventions on them.\r\n\r\nOCSConfiguratorFromClass will detect 4 kinds of methods. (Replace YourObjectKey each time with a unique name)\r\n\r\n```objective-c\r\n- (id) createSingleton/*YourObjectKey*/; //Lazy singleton definition\r\n- (id) createEagerSingleton/*YourObjectKey*/; //Eager singleton definition\r\n- (id) createPrototype/*YourObjectKey*/;//Prototype definition\r\n- (NSArray *) aliasesFor/*YourObjectKey*/;//Alias definitions\r\n```\r\nLet's look at them in more detail:\r\n\r\n#### Defining singletons\r\n\r\nFor each lazy singleton you need, you should add a method with the following signature:\r\n\r\n```objective-c\r\n- (id) createSingletonFoo {\r\n\treturn [[[Foo alloc] init] autorelease];\r\n}\r\n```\r\n\r\nYou can also use what is called *constructor injection* by calling another \r\n*createSingleton* or *createEagerSingleton* method:\r\n\r\n```objective-c\r\n- (id) createSingletonBar {\r\n\treturn [[[Bar alloc] initWithSomeObject:[self createSingletonFoo]] autorelease];\r\n}\r\n```\r\n\r\nDon't worry about calling the same *createSingleton* method more then once, the framework\r\nwill only really call each method once and reuse the same result on the succeeding calls,\r\nmaking the results true singletons.\r\n\r\nYou don't necessarily need to inject your objects through constructor injection. Later on\r\nwe will explain how objects are injected through the use of properties.\r\n\r\nTo create eager singletons, add this kind of method:\r\n\r\n```objective-c\r\n- (id) createEagerSingletonFooBar {\r\n\treturn [[[FooBar alloc] init] autorelease];\r\n}\r\n```\r\n\r\n#### Defining prototypes\r\n\r\nFor creating prototypes we can use a similar approach. Only the method name changes a bit:\r\n\r\n```objective-c\r\n- (id) createPrototypeFooBar {\r\n\treturn [[[FooBar alloc] init] autorelease];\r\n}\r\n```\r\n\r\n**Remember:** each time a prototype is requested, this method will be called. You should \r\ntherefore consider to keep the initialization as performant as possible.\r\n\r\n#### Registering aliases for an object\r\n\r\nRegistering aliases for an object is also possible. Again, you just need to add a method\r\nwith a certain signature:\r\n\r\n```objective-c\r\n- (NSArray *) aliasesForFoo {\r\n\treturn [NSSet setWithObjects:@\"_foo\", @\"_fuu\", nil];\r\n}\r\n```\r\n\r\n**Remark:** by default, two aliases are already registered for each object. They take the\r\nform of the key in uppercase (eg. FOO, BAR, FOOBAR, ...) and the key starting with a\r\nlowercase (eg. foo, bar, fooBar, ...). Aliases must be unique, and should also never be\r\nequal to an object key. If an attempt is made to add a duplicate, an exception will be\r\nraised. The automatically added aliases, will only be added if they are not a duplicate of\r\nthe key.\r\n\r\n#### Other methods in your factory class\r\n\r\nYou can add other methods, which might help in creating your objects. These will be\r\nignored by the framework, but you can obviously use them in your create methods.\r\n\r\n#### Dealing with larger applications\r\n\r\nIn larger applications, the factory class can quickly become huge. This is where you can\r\nand should use Objective-C's\r\n[category](http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/objectivec/chapters/occategories.html \"Objective-C programming language reference\")\r\nmechanism. For each logical group of objects you can create a category, named after this\r\nlogical group. All methods in all categories of your factory class will be taken into\r\naccount. It might look something like this (interfaces will be omitted for brevity).\r\n\r\n```objective-c\r\n@implementation ReliantFactory\r\n\r\n- (id) createSingletonGeneralObject {\r\n\treturn ...;\r\n}\r\n\r\n@end\r\n\r\n@implementation ReliantFactory (Services)\r\n\r\n- (id) createEagerSingletonServiceA {\r\n\treturn [[[ServiceA alloc] init] autorelease];\r\n}\r\n\r\n- (id) createEagerSingletonServiceB {\r\n\treturn [[[ServiceB alloc] init] autorelease];\r\n}\r\n\r\n@end\r\n\r\n@implementation ReliantFactory (Repositories)\r\n\r\n- (id) createEagerSingletonRepositoryA {\r\n\treturn [[[RepositoryA alloc] init] autorelease];\r\n}\r\n\r\n- (id) createEagerSingletonRepositoryB {\r\n\treturn [[[RepositoryB alloc] init] autorelease];\r\n}\r\n\r\n@end\r\n\r\n```\r\n\r\n### Injection\r\n\r\nAll objects created in the application context will be injected after their creation. This\r\nis done as explained before by *constructor injection* and/or by using Objective-C's \r\n[KVC](http://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html \"Key-Value Coding Programming Guide\")\r\nmechanism. Reliant will scan your object's properties. If a writable property's name\r\nmatches with a key or alias for an object in the application context, and if it's current\r\nvalue is nil, the matching object will be injected in this property. All other properties\r\nwill be left alone. This will be done for the entire class hierarchy of the instance.\r\n\r\n#### Injecting objects that are not know to the application context\r\n\r\nYou can use the injection mechanism described above on objects which are not setup in the \r\napplication context. A good example would be a UIViewController. In order to make things\r\neasier, you can make use of the fact that we have bootstrapped our application context in\r\nthe UIApplicationDelegate. Since the UIApplication is a shared object (hey, another\r\nsingleton!) we can do our injection from here.\r\n\r\n**Remark:** We already discussed that Reliant will clear it's singleton cache whenever a\r\nmemory warning occurs. Reliant thereby releases it's ownership of the instances. However,\r\nit can not be held responsible for the objects injected outside of it's scope as discussed\r\nabove. You should therefore retain/release any injected objects yourself. For property injection,\r\nthis means that your dependent properties should have the retain attribute on it.\r\n\r\nThis is what you need to do:\r\n\r\n```objective-c\r\n//In your UIApplicationDelegate\r\n@implementation MyAppDelegate {\r\n\tOCSApplicationContext *_context;\r\n}\r\n\r\n- (BOOL)application:(UIApplication *)application \r\n\tdidFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\r\n\t//...\r\n\t\r\n\t//Initialize a configurator\r\n\tid<OCSConfigurator> configurator = [[OCSConfiguratorFromClass alloc] \r\n\t\tinitWithClass:[YourObjectFactory class]];\r\n\r\n\t//Initialize the application context with the configurator\r\n\t_context = [[OCSApplicationContext alloc] initWithConfigurator:configurator];\r\n\r\n\t//Start the context\r\n\t[_context start];\r\n\t\r\n\t//...\r\n\r\n}\r\n\r\n- (void) performInjectionOn:(id) object {\r\n\t[_context performInjectionOn:object];\r\n}\r\n\r\n@end;\r\n\r\n//In your UIViewController\r\n@implementation MyViewController\r\n\r\n@synthesize foo;\r\n\r\n- (void) viewDidLoad {\r\n    [super viewDidLoad];\r\n    \r\n    AppDelegate *appDelegate = (AppDelegate *) [UIApplication sharedApplication].delegate;\r\n    [appDelegate performInjectionOn:self];\r\n}\r\n\r\n- (void) viewDidUnload {\r\n\t//Set any injected property to nil here!\r\n\tself.foo = nil\r\n\t\r\n\t[super viewDidUnload];\r\n}\r\n\r\n@end\r\n```\r\n\r\nAnd that's all there is to it. The property foo will be injected by Reliant.\r\n\r\n### The configurator\r\n\r\nAs we already saw, a configurator is responsible for setting up definitions and creating\r\nobject instances based on those definitions. Although a default class configurator\r\n(*OCSConfiguratorFromClass*) is provided by Reliant, you can always build your own. Your\r\ncustom configurator should conform to the *OCSConfigurator* protocol. In the\r\nconfigurator's designated initializer, you should start building your object definitions.\r\nA configurator, although not enforced, should maintain it's own definition registry. A\r\nconfigurator should not start creating instances for these definitions just until the\r\ncontextLoaded: message is send to it. Only after all work is done should the configurator\r\nreturn objects through its objectForKey:inContext: method. When work is done, the\r\ninitializing property should be true/YES/whatever-other-bool-literal-you-prefer.\r\n\r\nAn abstract implementation is also provided. This is the *OCSConfiguratorBase* which deals\r\nwith the boiler plate code for keeping track of registered definitions and object. If you\r\nextend this class, you should import the *OCSConfiguratorBase+ForSubclassEyesOnly.h*\r\nheader in your implementation (.m file). This will alow you to call \"protected\" methods\r\nand properties, hidden for non-extending classes. You should never use\r\nthis category outside of a subclass, doing so will cause unexpected behavior.\r\n\r\nIf you extend OCSConfiguratorBase, you should not override the methods defined in\r\nOCSConfigurator. You must instead implement createObjectInstanceForKey:inContext: and\r\ninternalContextLoaded: (See API documentation for more information)\r\n\r\n**Remark:** Although the framework is extendible, we encourage you to use the provided\r\nOCSConfiguratorFromClass or extend via the OCSConfiguratorBase.\r\n\r\n#### Example\r\n\r\n```objective-c\r\n//  CustomConfigurator.h\r\n\r\n@interface CustomConfigurator : OCSBaseConfigurator\r\n\r\n@end\r\n\r\n\r\n// CustomConfigurator.m\r\n\r\nTODO\r\n\r\n@end\r\n```\r\n\r\nInteresting references/discussions\r\n----------------------------------\r\n\r\n- [Discussion](http://stackoverflow.com/questions/309711/dependency-injection-framework-for-cocoa \"StackOverflow\") on the necessity of DI in Objective C/Dynamic languages \r\n\r\nInspirational projects / credits\r\n--------------------------------\r\n\r\n- [Spring framework](http://www.springsource.org/spring-framework#documentation \"SpringSource Spring framework\"). \r\nI dare say this is the de facto standard IoC container in the Java world. \r\nAlthough going much (much ... much) further then DI, this framework was one of if not the \r\npioneer in DI framework. Since spring 3.0, a Configuration class system is available. Reliant\r\nbuilds on this principle.\r\n\r\n- [Guice](http://code.google.com/p/google-guice/ \"Google Guice\"). Google's type safe DI \r\nsolution. Partially as an answer to spring, which was not very strong on the type-safety \r\nside of things at that time. Spring fixed this in version 3.0.\r\nAlthough Guice is a very well thought of DI framework, which should be marvelled for it's\r\nsimplicity and light-weightness, I personally feel that basing a DI framework for a\r\ndynamic language on Guice is a bridge too far. It would break down too many of the main\r\ngoals of Guice, namely type safety. I'm not saying type safety is unimportant, I'm just\r\nsaying that Objective-C (and other dynamic languages for that matter) needs a different\r\napproach.\r\n\r\n- [Objection](http://objection-framework.org/ \"AtomicObject Objection\"). Another DI\r\nframework for Objective-C, based on Guice. As stated before, the \"binding\" approach did\r\nlook appealing to me at first, but I don't think binding to types works very well in\r\nObjective-C. But still, a very well made port.\r\n\r\nSpecial thanks\r\n--------------\r\n\r\n- Filip Maelbrancke: for second opinions and rubber ducking\r\n- Bart Vandeweerdt: for reviewing this documentation\r\n- iDA MediaFoundry: for letting me use this in production code\r\n- Oak Consultancy Services: for necessary resources\r\n- Liesbet Gouwy: for unconditional support\r\n- Kato Seghers: for being born\r\n\r\nContact\r\n-------\r\nIf not via GitHub, find me on twitter: @mikeseghers\r\n\r\nLicence\r\n-------\r\n\r\nReliant is released under the [Apache License, Version 2.0](http://www.apache.org/licenses/LICENSE-2.0)","tagline":"","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}